#!/usr/bin/env python
'''git-issue is a stupid issue tracking module for Git.

'''
from __future__ import unicode_literals
from collections import namedtuple
from io import open

import os
import time
import argparse
import logging
import subprocess
import sys
import json
import binascii

try:
    from itertools import zip_longest
except ImportError:
    from itertools import izip_longest as zip_longest

logger_name = 'git-issue' if __name__ == '__main__' else __name__
logging.basicConfig(format='%(message)s')
logger = logging.getLogger(logger_name)
logger.setLevel(logging.INFO)

global_branch = None

ISSUE_LIST_FILE = 'issues'
ISSUE_TEMPLATE = """
# Anything below this line will be ignored.
# The ideal structure of a message looks like:
#
#  Capitalized, short (50 chars or less) summary
#
#   Milestone: milestone1 milestone2
#
#   Tag: tag1 tag2 tag3
#
#   Assign: Justin Bruce Van Horne <justinvh@gmail.com>
#
#   More detailed explanatory text, if necessary.  Wrap it to about 72
#   characters or so.  In some contexts, the first line is treated as the
#   subject of an email and the rest of the text as the body.  The blank
#   line separating the summary from the body is critical (unless you omit
#   the body entirely);
"""

Issue = namedtuple('Issue', ['resolved', 'milestones', 'tags', 'created',
                             'assigned', 'unique_id', 'branch', 'commit'])


def chunks(l, n):
    for i in range(0, len(l), n):
        yield l[i:i+n]


class Git:
    @staticmethod
    def stash():
        return Git.command('stash')

    @staticmethod
    def pull():
        return Git.command('pull')

    @staticmethod
    def yield_commit_if_log_contains(what):
        """Yields a single commit if a particular log entry
        contains 'what' in it.

        TODO(justinvh): Figure out why --grep doesn't work?

        """
        args = ('--no-pager', 'log', '--decorate=short'.format(what))
        results = Git.command(*args)
        start_index = -1
        for i, line in enumerate(results):
            if line.startswith('commit'):
                start_index = i
            if start_index >= 0 and what in line:
                commit = results[start_index].split(' ')[1]
                start_index = -1
                yield commit

    @staticmethod
    def fetch_log_by_commit(commit, message_only=False):
        args = ('--no-pager', 'show', '--name-only', commit)
        message = Git.command(*args)
        if message_only:
            return message[4:]
        return message

    @staticmethod
    def stash_pop():
        return Git.command('stash', 'pop')

    @staticmethod
    def email():
        return Git.properties('user.email')

    @staticmethod
    def properties(what):
        return Git.command('config', what)

    @staticmethod
    def branch():
        return Git.command('rev-parse', '--abbrev-ref', 'HEAD')[0]

    @staticmethod
    def branch_create(name, orphan=False):
        if orphan:
            return Git.command("checkout", "--orphan", name)
        return Git.command("checkout", "-b", name)

    @staticmethod
    def branch_checkout(name):
        return Git.command("checkout", name)

    @staticmethod
    def fetch():
        return Git.command("fetch")

    @staticmethod
    def branch_remote_checkout(name, remote):
        if 'fatal' in Git.fetch():
            return False
        return Git.command("checkout", "-b", name, remote)

    @staticmethod
    def branch_delete(name):
        return Git.command("branch", "-D", name)

    @staticmethod
    def local_branch_exists(name):
        msg = Git.command("show-ref", "--verify", "refs/heads/{}".format(name))
        return 'fatal' not in msg

    @staticmethod
    def remote_branch_exists(name):
        for branch in Git.command('branch', '-r'):
            branch = branch.strip()
            if branch.endswith(name):
                return branch
        return None

    @staticmethod
    def rm(what, recursive=False):
        if recursive:
            return Git.command('rm', '-rf', what)
        return Git.command('rm', what)

    @staticmethod
    def commit_exists():
        return "fatal" not in Git.command('rev-list', 'HEAD')

    @staticmethod
    def commit(filename=None, from_file=None, from_message=None):
        if filename is None:
            return Git.command('rev-parse', '--verify', 'HEAD')[0]
        if from_file:
            return Git.command('commit', filename, '-F', from_file)
        elif from_message:
            return Git.command('commit', filename, '-m', from_message)

    @staticmethod
    def repository():
        return Git.command('rev-parse', '--show-toplevel')[0]

    @staticmethod
    def add(what):
        return Git.command('add', what)

    @staticmethod
    def command(*args, **kwargs):
        try:
            command = ['git'] + list(args)
            logger.debug(' '.join(command))
            msg = subprocess.check_output(command, stderr=subprocess.STDOUT)
            msg = msg.decode('utf-8')
            return msg.splitlines()
        except subprocess.CalledProcessError as e:
            return e.output


def issue_create(args):
    '''Creates a new issue.

    '''
    current_branch = Git.branch()
    current_commit = Git.commit()
    if not os.environ.get('EDITOR'):
        logger.info('EDITOR is not set in your environment. Please set it.')
        logger.info('Defaulting to vim.')
        os.environ['EDITOR'] = 'vim'

    # Check if the git-issues branch exists.
    repository_dir = Git.repository()
    issue_dir = repository_dir
    Git.branch_checkout("git-issues")

    issues = []
    issue_list_file = os.sep.join([issue_dir, ISSUE_LIST_FILE])
    if os.path.exists(issue_list_file):
        issues = json.load(open(issue_list_file))

    unique_issue_id = binascii.b2a_hex(os.urandom(3))

    # Write the issue template
    issue_file = os.sep.join([issue_dir, unique_issue_id])
    with open(issue_file, 'w') as issue:
        issue.write(ISSUE_TEMPLATE)

    # Invoke the editor and open the issue file
    ret = subprocess.call([os.environ.get('EDITOR'), issue_file])
    if ret != 0:
        print('Aborting issue due to empty issue message.')
        return

    milestones = []
    tags = []
    assigned = []

    # Read what the issue was and check if it was empty.
    valid_issue = ''
    with open(issue_file) as issue:
        lines = issue.read().strip().splitlines()
        valid_lines = [x for x in lines if not x.startswith('#')]
        if not valid_lines:
            os.remove(issue_file)
            print('Aborting issue due to empty issue message.')
            return

        for line in valid_lines:
            # Break the milestones
            lowered = line.lower()
            if lowered.startswith('milestone:'):
                milestones = line[10:].split()
            elif lowered.startswith('tag:'):
                tags = line[4:].split()
            elif lowered.startswith('assign:'):
                assigned.append(line[7:])
        valid_issue = '\n'.join(valid_lines)

    # Write the cleaned up issue
    issue_filename = issue_file
    with open(issue_file, 'w') as issue:
        issue.write(valid_issue)

    # Get the commit details
    created = int(time.time())
    issues.append({'unique_id': unique_issue_id,
                   'commit': current_commit,
                   'branch': current_branch,
                   'created': str(created),
                   'milestones': milestones,
                   'tags': tags,
                   'description': valid_issue[:80].split('\n')[0],
                   'assigned': assigned,
                   'resolved_in': False,
                   'resolved': False})

    json.dump(issues, open(issue_list_file, 'wb'), indent=4)

    msg = 'created issue {} on branch {} at commit {}.'
    msg = msg.format(unique_issue_id, current_branch, current_commit)
    Git.add(issue_dir)
    Git.commit(issue_dir, from_file=issue_filename)
    print(msg)


def issue_list(args):
    '''Lists creates issues.

    '''
    # By default we have to ensure that the git-issue branch even exists
    issue_local_branch_exists = Git.local_branch_exists('git-issues')
    if not issue_local_branch_exists:
        sys.exit('No issues has been created.')

    # Verify that an issue list even exists
    Git.branch_checkout("git-issues")
    repository_dir = Git.repository()
    issue_dir = repository_dir
    issue_list_file = os.sep.join([issue_dir, ISSUE_LIST_FILE])
    if not os.path.exists(issue_list_file):
        sys.exit('No issues exist.')

    # Load the issues
    issues = json.load(open(issue_list_file))
    results = [[i for i, _ in enumerate(issues)]]

    # Gather all the resolved issues
    if args.resolved:
        temp_results = []
        for i, issue in enumerate(issues):
            if issue['resolved']:
                temp_results.append(i)
        results.append(temp_results)

    # Gather all the issues specified by ID
    ids = args.id
    if ids:
        temp_results = []
        for i, issue in enumerate(issues):
            if issue['unique_id'] in ids:
                temp_results.append(i)
        results.append(temp_results)

    # Gather all the issues specified with a certain tag
    tags = set(args.tag)
    if tags:
        temp_results = []
        for i, issue in enumerate(issues):
            if set(issue['tags']) & tags:
                temp_results.append(i)
        results.append(temp_results)

    # Gather all the issues specified with a certain milestone
    milestone = set(args.milestone)
    if milestone:
        temp_results = []
        for i, issue in enumerate(issues):
            if set(issue['milestones']) & milestone:
                temp_results.append(i)
        results.append(temp_results)

    # Check the assign-list vs the issue users with a find()
    assigned = args.assign
    if assigned:
        temp_results = []
        for i, issue in enumerate(issues):
            for user in issue['assigned']:
                user = user.lower()
                for assign in assigned:
                    assign = assign.lower()
                    if user.find(assign) != -1:
                        temp_results.append(i)
                        break
                else:
                    continue
                break
        results.append(temp_results)

    # Find the intersection of the results
    temp_results = set(results[0])
    for result in results[1:]:
        temp_results &= set(result)
    results = [issues[i] for i in temp_results]

    if not results:
        return

    # Create a structure for tabulating the data
    ignored = ['description', 'unique_id', 'commit', 'branch', 'resolved', 'created', 'resolved_in']
    key_size = len(list(results[0].keys())) - len(ignored)
    table_format = '{:^19} ' * key_size
    newline = '-' * 20 * key_size

    # Remove the description from the key-list
    keys = list(issues[0].keys())
    for ignore in ignored:
        keys.remove(ignore)

    for issue in results:
        # Store the current data so we can print it on multiple
        # rows, but under the same issue.
        resolved_text = 'resolved' if issue['resolved'] else 'unresolved'
        created = float(issue['created'])
        created = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(created))
        issue_args = (issue['unique_id'], resolved_text, issue['branch'],
                      issue['commit'][:5], created)
        print('Issue {} {} - {}:{} - {}'.format(*issue_args))
        print(issue['description'])

        # In short-description mode we can bail early
        if args.short:
            print()
            continue

        # delete the used keys
        for ignore in ignored:
            del issue[ignore]

        # Print the headers
        print(newline)
        print(table_format.format(*keys))
        print(newline)

        # Grab the iterables up-front
        milestones = issue['milestones']
        tags = issue['tags']
        assigned = issue['assigned']

        # The data will be displayed in multiple-rows, so we will need to
        # fill the empty columns with a placeholder
        zipped = list(zip_longest(milestones, tags, assigned, fillvalue='-'))

        # In the case we don't have tags, milestones, or an assigned user
        # So, just fill with the placeholder text
        if not zipped:
            issue['milestones'] = '-'
            issue['tags'] = '-'
            issue['assigned'] = '-'
            print(table_format.format(*list(issue.values())))
            print(newline)
            print('')
            continue

        # Break each row for the milestones, tags, and assigned
        for m, t, a in zipped:
            issue['milestones'] = m
            issue['tags'] = t
            issue['assigned'] = a[:16] + ('...' if len(a) > 16 else '')
            print(table_format.format(*list(issue.values())))

        print(newline)
        print('')


def issue_resolve(args):
    '''Resolves created issues.

    '''
    issue_local_branch_exists = Git.local_branch_exists('git-issues')
    if not issue_local_branch_exists:
        sys.exit('No issues created.')

    # Verify that an issue list even exists
    Git.branch_checkout("git-issues")
    repository_dir = Git.repository()
    issue_dir = repository_dir
    issue_list_file = os.sep.join([issue_dir, ISSUE_LIST_FILE])
    if not os.path.exists(issue_list_file):
        sys.exit('No issues exist.')

    # Load the issues
    issues = json.load(open(issue_list_file))

    # Gather all unresolved issues
    commit_issues = {}
    fn_issues = {}
    for issue in issues:
        resolved_in = issue.get('resolved_in')
        fn = issue.get('unique_id')
        if resolved_in:
            commit_issues[resolved_in] = issue
        fn_issues[fn] = issue

    unresolved = [(i['unique_id'], i) for i in issues]
    logger.debug('{} unresolved issues'.format(len(unresolved)))

    issue_was_resolved = False

    # Now check back into the last branch
    Git.branch_checkout(global_branch)

    # Gather all the history
    updates = []
    for commit in Git.yield_commit_if_log_contains("Fixes:"):
        if commit_issues.get(commit):
            continue
        fixes = []
        log = Git.fetch_log_by_commit(commit, message_only=True)
        # Iterate through the log backwards and look for fixes attr.
        for line in reversed(log):
            line = line.strip()
            if line.startswith('Fixes:'):
                fixes = line.split(':')[1].split(',')
                break
        for fix in fixes:
            fix = fix.strip()
            updates.append(fix)
            fix = int(fix)
            issue = fn_issues.get(fix)
            if not issue:
                msg = 'Failed to find issue #{} as specified on commit {}'
                logger.info(msg.format(fix, commit))
                continue
            issue_was_resolved = True
            msg = ('==================================================\n'
                   'Resolving issue #{} with {} on {}:\n'
                   '==================================================\n'
                   '{}\n'
                   '--------------------------------------------------\n'
                   'With commit {} on {}:\n'
                   '--------------------------------------------------\n'
                   '{}\n')
            issue_commit = issue['commit']
            issue_branch = issue['branch']
            issue['resolved'] = True
            issue['resolved_in'] = commit
            resolved_log = '\n'.join([l.strip() for l in log])
            description = issue['description']
            args = (fix, issue_commit[:8], issue_branch, description,
                    commit[:8], global_branch, resolved_log)
            logger.info(msg.format(*args))

    # No issues found, let the user know.
    if not issue_was_resolved:
        print('No issue could be resolved.')
        return

    # Ask if we should commit our changes
    if raw_input('Do you want to continue (y/n) ').lower() == 'y':
        Git.branch_checkout('git-issues')
        json.dump(issues, open(issue_list_file, 'wb'), indent=4)
        commit_msg = 'Resolves issues {}'.format(', '.join(updates))
        Git.commit(Git.repository(), from_message=commit_msg)

def issue_delete(args):
    '''Deletes an issue.

    '''


def argument_create():
    '''Provides some organizational qualities to the argument parsing
    for git-issue.

    '''
    parser = argparse.ArgumentParser(prog='git issue')
    cmd = parser.add_subparsers(title='Available git-issue actions')

    def argument_create():
        '''Arguments pertaining to creating an issue

        '''
        option = cmd.add_parser('create', help='create a new issue')
        option.add_argument('-s', '--stdin',
                            action='store_true',
                            help='Read issue message from stdin')
        option.set_defaults(func=issue_create)

    def argument_list():
        '''Arguments pertaining to listing issues.

        '''
        option = cmd.add_parser('list', help='list available issues')
        option.add_argument('-i', '--id',
                            help='list only with a certain id',
                            default=[],
                            type=int,
                            action='append')

        option.add_argument('-t', '--tag',
                            help='list only by a certain tag',
                            default=[],
                            action='append')

        option.add_argument('-m', '--milestone',
                            help='list only by a certain milestone',
                            default=[],
                            action='append')

        option.add_argument('-a', '--assign',
                            help='list only by a certain user',
                            default=[],
                            action='append')

        option.add_argument('-s', '--short',
                            help='short list',
                            action='store_true')

        option.add_argument('-r', '--resolved',
                            default=False,
                            help='list only resolved issues',
                            action='store_true')

        option.set_defaults(func=issue_list)

    def argument_resolve():
        '''Arguments pertaining to resolving an issue.

        '''
        option = cmd.add_parser('resolve', help='resolve an issue')
        option.set_defaults(func=issue_resolve)

        option = cmd.add_parser('delete', help='delete an issue')
        option.set_defaults(func=issue_delete)

    def argument_general():
        '''Arguments pertaining to general use of git-issue.

        '''
        parser.add_argument('-q', '--quiet',
                            action='store_true',
                            help='supress all output')

        parser.add_argument('-v', '--verbose',
                            action='store_true',
                            help='enable debugging output')

    argument_create()
    argument_list()
    argument_resolve()
    argument_general()

    return parser


if __name__ == '__main__':
    parser = argument_create()
    args = parser.parse_args()

    if args.verbose:
        logger.setLevel(logging.DEBUG)

    if not Git.commit_exists():
        sys.exit('Issues can not be created without a HEAD')

    Git.stash()
    global_branch = Git.branch()
    logger.debug('Current branch is {}'.format(global_branch))

    try:
        # Check if the git-issues branch exists.
        issue_local_branch_exists = Git.local_branch_exists('git-issues')
        repository_dir = Git.repository()
        issue_dir = repository_dir
        if not issue_local_branch_exists:
            # Create the issue directory if necessary
            logger.info("Checking if remote exists")
            remote = Git.remote_branch_exists('git-issues')
            if remote:
                logger.info('Remote exists, checking it out.')
                Git.branch_remote_checkout('git-issues', remote)
            else:
                logger.info("Remote does not exist. Creating branch.")
                Git.branch_create('git-issues', orphan=True)
                Git.rm(".", recursive=True)
                issue_list_file = os.sep.join([issue_dir, ISSUE_LIST_FILE])
                with open(issue_list_file, 'wb') as f:
                    f.write('[]')
                Git.add(issue_list_file)
                Git.commit(issue_list_file, from_message='Initial commit.')
        Git.branch_checkout('git-issue')
        Git.pull()
        args.func(args)
    except AttributeError as e:
        logger.exception(e)
        parser.print_help()
    finally:
        Git.branch_checkout(global_branch)
        Git.stash_pop()
