#!/usr/bin/env python
'''git-issue is a stupid issue tracking module for Git.

'''
from __future__ import unicode_literals
from collections import namedtuple
import subprocess

def git_getconfig(key, default=None):
    try:
        return subprocess.check_output(['git', 'config', key])
    except subprocess.CalledProcessError:
        return default

# You are free to edit any of the following to match your respective
# language, issue-feel, and so on.

# The branch that is created to store the issues.
ISSUE_BRANCH = git_getconfig('issue.branch', 'git-issues')

# When EDITOR is not specified in the environment, this is invoked:
EDITOR_ENVIRONMENT = git_getconfig('issue.editor.environment', 'EDITOR')
DEFAULT_EDITOR = git_getconfig('issue.editor.path', 'vim')

# The tokens are the values searched for the leading-lines in a message.
TOKEN_ASSIGN = git_getconfig('issue.tokens.assign', 'assign:')
TOKEN_TAG = git_getconfig('issue.tokens.tag', 'tags:')
TOKEN_MILESTONE = git_getconfig('issue.tokens.milestone', 'milestone:')
TOKEN_FIXES = git_getconfig('issue.tokens.fixes', 'fixes:')

# We need these values so we can split() correctly.
TOKEN_ASSIGN_LENGTH = len(TOKEN_ASSIGN)
TOKEN_TAG_LENGTH = len(TOKEN_TAG)
TOKEN_MILESTONE_LENGTH = len(TOKEN_MILESTONE)

# The issue template is written to a temporary file and is invoked by the
# user's EDITOR to create a new issue.
ISSUE_TEMPLATE = """
# Anything below this line will be ignored.
# The ideal structure of a message looks like:
#
#  Capitalized, short (50 chars or less) summary
#
#   Milestone: milestone1 milestone2
#
#   Tag: tag1 tag2 tag3
#
#   Assign: Justin Bruce Van Horne <justinvh@gmail.com>
#
#   More detailed explanatory text, if necessary.  Wrap it to about 72
#   characters or so.  In some contexts, the first line is treated as the
#   subject of an email and the rest of the text as the body.  The blank
#   line separating the summary from the body is critical (unless you omit
#   the body entirely);
"""

ISSUE_LIST_DESCRIPTION_TEMPLATE = '{issue_description}'
ISSUE_LIST_HEADER_TEMPLATE = ('Issue {issue_hash} {issue_resolved} - '
                              '{issue_branch}:{issue_commit} - '
                              '{issue_created}')

# The resolved template is what is output to the console as well as committed
# in the issue-branch
RESOLVED_TEMPLATE = """
==================================================
Resolving issue #{issue_hash} with {issue_commit} on {issue_branch}
==================================================
{issue_description}
--------------------------------------------------
With commit {resolved_commit} on {resolved_branch}
--------------------------------------------------
{resolved_log}
"""

STRINGS = {
    'no_head': 'Issues can not be created without the HEAD',
    'bad_editor': '{} is not set in your environment. Please set it.',
    'default_editor': 'Defaulting to {}',
    'empty_issue': 'Aborting issue due to empty issue message',
    'issue_created': ('created issue {issue_hash} on branch '
                        '{issue_branch} at commit {issue_commit}'),
    'no_issues': 'No issues have been created',
    'bad_resolve': 'Failed to find #{issue_hash} as seen in {resolved_commit}',
    'no_resolve': 'No issues could be resolved',
    'tag_resolved': 'tag-{issue_hash}-resolved',
    'tag_created': 'Creating tag {tag} at {commit}',
    'ask_commit': 'Do you want to continue (y/n) ',
    'ask_commit_yes': 'y'
}

# We created an object from our strings because it's annoying to
# just use [] everywhere.
locale_msg = namedtuple('Locale', STRINGS.keys())(*STRINGS.values())

# Anything below here is the actual implementation.

from io import open

import os
import time
import argparse
import logging
import sys
import json
import binascii

try:
    from itertools import zip_longest
except ImportError:
    from itertools import izip_longest as zip_longest

logger_name = 'git-issue' if __name__ == '__main__' else __name__
logging.basicConfig(format='%(message)s')
logger = logging.getLogger(logger_name)
logger.setLevel(logging.INFO)

global_branch = None


class Git:
    """Static methods for manipulating a Git repository.

    Since we're already invoking git, we really don't really need to guarantee
    on an external repository since we already are in one.

    """
    @staticmethod
    def stash():
        return Git.command('stash')

    @staticmethod
    def pull():
        return Git.command('pull')

    @staticmethod
    def yield_commit_if_log_contains(what):
        """Yields a single commit if a particular log entry
        contains 'what' in it.

        TODO(justinvh): Figure out why git log --grep doesn't work?

        """
        args = ('--no-pager', 'log', '--decorate=short'.format(what))
        results = Git.command(*args)
        start_index = -1
        for i, line in enumerate(yield_lower(results)):
            if line.startswith('commit'):
                start_index = i
            line = line.strip()
            if start_index >= 0 and line.startswith(what):
                commit = results[start_index].split(' ')[1]
                start_index = -1
                yield commit

    @staticmethod
    def fetch_log_by_commit(commit, message_only=False):
        args = ('--no-pager', 'show', '--name-only', commit)
        message = Git.command(*args)
        if message_only:
            return message[4:]
        return message

    @staticmethod
    def stash_pop():
        return Git.command('stash', 'pop')

    @staticmethod
    def email():
        return Git.properties('user.email')

    @staticmethod
    def properties(what):
        return Git.command('config', what)

    @staticmethod
    def branch():
        return Git.command('rev-parse', '--abbrev-ref', 'HEAD')[0]

    @staticmethod
    def branch_create(name, orphan=False):
        if orphan:
            return Git.command("checkout", "--orphan", name)
        return Git.command("checkout", "-b", name)

    @staticmethod
    def branch_checkout(name):
        return Git.command("checkout", name)

    @staticmethod
    def fetch():
        return Git.command("fetch")

    @staticmethod
    def branch_remote_checkout(name, remote):
        if 'fatal' in Git.fetch():
            return False
        return Git.command("checkout", "-b", name, remote)

    @staticmethod
    def branch_delete(name):
        return Git.command("branch", "-D", name)

    @staticmethod
    def local_branch_exists(name):
        msg = Git.command("show-ref", "--verify", "refs/heads/{}".format(name))
        return 'fatal' not in msg

    @staticmethod
    def remote_branch_exists(name):
        for branch in Git.command('branch', '-r'):
            branch = branch.strip()
            if branch.endswith(name):
                return branch
        return None

    @staticmethod
    def tag(name, commit, from_file=None):
        if from_file:
            return Git.command('tag', name, commit, '-F', from_file)
        return Git.command('tag', name, commit)

    @staticmethod
    def rm(what, recursive=False):
        if recursive:
            return Git.command('rm', '-rf', what)
        return Git.command('rm', what)

    @staticmethod
    def commit_exists():
        return "fatal" not in Git.command('rev-list', 'HEAD')

    @staticmethod
    def commit(filename=None, empty=False, from_file=None, from_message=None):
        if empty:
            return Git.command('commit', '--allow-empty', from_message)
        if filename is None:
            return Git.command('rev-parse', '--verify', 'HEAD')[0]
        if from_file:
            return Git.command('commit', filename, '-F', from_file)
        elif from_message:
            return Git.command('commit', filename, '-m', from_message)

    @staticmethod
    def repository():
        return Git.command('rev-parse', '--show-toplevel')[0]

    @staticmethod
    def add(what):
        return Git.command('add', what)

    @staticmethod
    def command(*args, **kwargs):
        try:
            command = ['git'] + list(args)
            logger.debug(' '.join(command))
            msg = subprocess.check_output(command, stderr=subprocess.STDOUT)
            msg = msg.decode('utf-8')
            return msg.splitlines()
        except subprocess.CalledProcessError as e:
            return e.output


class Issue(dict):
    def __init__(self, filename):
        self.filename = filename
        dict.__init__(self, json.load(open(filename)))

    def commit(self, filename):
        json.dump(self, open(filename, 'wb'))


def yield_lower(iterable):
    for i in iterable:
        yield i.lower()

def yield_strip(iterable):
    for i in iterable:
        yield i.strip()

def yield_issues():
    import glob
    for filename in glob.glob('*.issue.json'):
        yield Issue(filename)


def issue_create(args):
    '''Creates a new issue.

    '''
    current_branch = Git.branch()
    current_commit = Git.commit()

    # We expect EDITOR to be in the environment, but if it is not then
    # they get to deal with Vim, but we sleep for 2-seconds so the user
    # can at least see the problem.
    if not os.environ.get(EDITOR_ENVIRONMENT):
        print(locale_msg.bad_editor.format(EDITOR_ENVIRONMENT))
        print(locale_msg.default_editor.format(DEFAULT_EDITOR))
        os.environ[EDITOR_ENVIRONMENT] = DEFAULT_EDITOR
        time.sleep(2)

    # At this point the git-issues repository already exists
    repository_dir = Git.repository()
    issue_dir = repository_dir
    Git.branch_checkout(ISSUE_BRANCH)

    # Now we generate a 6-value ASCII string. urandom does use random for
    # seeding its values, so it is technically pseudo-random.
    unique_issue_id = binascii.b2a_hex(os.urandom(3))

    # Write the issue template so it is ready when the user's editor
    # invokes the file.
    issue_file = os.sep.join([issue_dir, unique_issue_id])
    with open(issue_file, 'w') as issue:
        issue.write(ISSUE_TEMPLATE)

    # Invoke the editor and open the issue file
    ret = subprocess.call([os.environ.get(EDITOR_ENVIRONMENT), issue_file])
    if ret != 0:
        print(locale_msg.empty_issue)
        return

    # Since we have this many-many relationship between issues and milestones,
    # tags, and assigned-list, we have to fan-out the values up-front
    # so we can present them reasonably.
    milestones = []
    tags = []
    assigned = []

    # At this point the user saved and their EDITOR wrote out a value to
    # the issue file, we need to verify that it is not empty and then
    # fetch out the various attributes.
    valid_issue = ''
    with open(issue_file) as issue:
        # Remove all leading and trailing spaces, then truncate comments.
        lines = issue.read().strip().splitlines()
        valid_lines = [x for x in lines if not x.startswith('#')]

        # A blank message is not an issue, so we remove the file and
        # alert the user that their issue failed.
        if not valid_lines:
            os.remove(issue_file)
            print(locale_msg.empty_issue)
            return

        # Iterate through the remaining lines and try to fetch out tokens
        # that match our format.
        for line in yield_lower(valid_lines):
            # Break the milestones
            if line.startswith(TOKEN_MILESTONE):
                milestones = line[TOKEN_MILESTONE_LENGTH:].split()
            elif line.startswith(TOKEN_TAG):
                tags = line[TOKEN_TAG_LENGTH:].split()
            elif line.startswith(TOKEN_ASSIGN):
                assigned.append(line[TOKEN_ASSIGN_LENGTH:])
        valid_issue = '\n'.join(valid_lines)

    # Write the cleaned up issue to disk.
    issue_filename = issue_file
    with open(issue_file, 'w') as issue:
        issue.write(valid_issue)

    # Create a new entry for the JSON pseudo-db
    created = int(time.time())
    issue = {'unique_id': unique_issue_id,
             'commit': current_commit,
             'branch': current_branch,
             'created': str(created),
             'milestones': milestones,
             'tags': tags,
             'description': valid_issue[:80].split('\n')[0],
             'assigned': assigned,
             'resolved_in': False,
             'resolved': False}

    logger.info(issue)

    json.dump(issue,
              open('{}.issue.json'.format(unique_issue_id), 'wb'),
              indent=4)

    # The commit for this entry will match the issue.
    kwargs = {'issue_hash': unique_issue_id,
              'issue_branch': current_branch,
              'issue_commit': current_commit}
    msg = locale_msg.issue_created.format(**kwargs)
    Git.add(issue_dir)
    Git.commit(issue_dir, from_file=issue_filename)
    print(msg)


def issue_list(args):
    '''Lists creates issues.

    '''
    # By default we have to ensure that the git-issue branch even exists
    issue_local_branch_exists = Git.local_branch_exists(ISSUE_BRANCH)
    if not issue_local_branch_exists:
        sys.exit(locale_msg.no_issues)

    # Verify that an issue list even exists
    Git.branch_checkout(ISSUE_BRANCH)

    # Create an intersection of the results
    available = set()
    resolved_set = set()
    id_set = set()
    tag_set = set()
    milestone_set = set()
    assigned_set = set()
    id_to_issue = {}

    for i, issue in enumerate(yield_issues()):
        id_to_issue[i] = issue
        available.add(i)

        # Gather all the resolved issues
        if args.resolved and issue['resolved']:
            resolved_set.add(i)

        # Gather all the issues specified by ID
        ids = args.id
        if ids and issue['unique_id'] in ids:
            id_set.add(i)

        # Gather all the issues specified with a certain tag
        tags = set(args.tag)
        if tags and set(issue['tags'] & tags):
            tag_set.add(i)

        # Gather all the issues specified with a certain milestone
        milestone = set(args.milestone)
        if milestone and set(issue['milestones']) & milestone:
            milestone_set.add(i)

        # Check the assign-list vs the issue users with a find()
        assigned = args.assign
        if assigned:
            for user in yield_lower(issue['assigned']):
                for assign in yield_lower(assigned):
                    if user.find(assign) != -1:
                        assigned_set.add(i)
                        break
                else:
                    continue
                break

    mapping = ((args.resolved, resolved_set), (args.id, id_set),
               (args.tag, tag_set), (args.milestone, milestone_set),
               (args.assign, assigned_set))
    distinct = [s for e, s in mapping if e]

    intersection = available
    for result in distinct:
        intersection &= result

    results = [id_to_issue[s] for s in intersection]

    if not results:
        return

    # Create a structure for tabulating the data
    ignored = ['description', 'unique_id', 'commit',
               'branch', 'resolved', 'created', 'resolved_in']
    key_size = len(list(results[0].keys())) - len(ignored)
    table_format = '{:^19} ' * key_size
    newline = '-' * 20 * key_size

    # Remove the description from the key-list
    keys = list(results[0].keys())
    for ignore in ignored:
        keys.remove(ignore)

    for issue in results:
        # Store the current data so we can print it on multiple
        # rows, but under the same issue.
        resolved_text = 'resolved' if issue['resolved'] else 'unresolved'
        created = float(issue['created'])
        created = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(created))
        issue_kwargs = {'issue_hash': issue['unique_id'],
                        'issue_resolved': resolved_text,
                        'issue_branch': issue['branch'],
                        'issue_commit': issue['commit'][:5],
                        'issue_created': created,
                        'issue_description': issue['description']}

        print(ISSUE_LIST_HEADER_TEMPLATE.format(**issue_kwargs))
        print(ISSUE_LIST_DESCRIPTION_TEMPLATE.format(**issue_kwargs))

        # In short-description mode we can bail early
        if args.short:
            print()
            continue

        # delete the used keys
        for ignore in ignored:
            del issue[ignore]

        # Print the headers
        print(newline)
        print(table_format.format(*keys))
        print(newline)

        # Grab the iterables up-front
        milestones = issue['milestones']
        tags = issue['tags']
        assigned = issue['assigned']

        # The data will be displayed in multiple-rows, so we will need to
        # fill the empty columns with a placeholder
        zipped = list(zip_longest(milestones, tags, assigned, fillvalue='-'))

        # In the case we don't have tags, milestones, or an assigned user
        # So, just fill with the placeholder text
        if not zipped:
            issue['milestones'] = '-'
            issue['tags'] = '-'
            issue['assigned'] = '-'
            print(table_format.format(*list(issue.values())))
            print(newline)
            print('')
            continue

        # Break each row for the milestones, tags, and assigned
        for m, t, a in zipped:
            issue['milestones'] = m
            issue['tags'] = t
            issue['assigned'] = a[:16] + ('...' if len(a) > 16 else '')
            print(table_format.format(*list(issue.values())))

        print(newline)
        print('')


def issue_resolve(args):
    '''Resolves created issues.

    '''
    # Verify that an issue list even exists
    Git.branch_checkout(ISSUE_BRANCH)
    issue_was_resolved = False

    # Load the issues
    unresolved = []
    id_to_issue = {}
    commit_issues = {}

    # Gather all unresolved issues so we can determine what can
    # be potentially mark as resolved.
    for issue in yield_issues():
        issue_resolved_in = issue['resolved_in']
        id_to_issue[issue['unique_id']] = issue
        if issue_resolved_in:
            commit_issues[issue_resolved_in] = issue
        else:
            unresolved.append(issue)

    logger.debug('{} unresolved issues'.format(len(unresolved)))


    # Now check back into the last branch so we can read the logs
    Git.branch_checkout(global_branch)

    # Gather all the history
    updates = []
    resolved_branch = global_branch
    for resolved_commit in Git.yield_commit_if_log_contains(TOKEN_FIXES):
        # If we already processed this commit, then skip it.
        if commit_issues.get(resolved_commit):
            continue

        # Retrieve the actual history for the commit and then determine
        # what it actually fixes relative to our issue-list
        fixes = []
        log = Git.fetch_log_by_commit(resolved_commit, message_only=True)

        # Iterate through the log backwards since the Fixes-token will most
        # likely be at the end of the log. Issues are in the form of:
        # {TOKEN_FIXES}: issue1, issue2, issue3
        for line in reversed(yield_strip(log)):
            if line.startswith(TOKEN_FIXES):
                fixes = line.split(':')[1].split(',')
                break

        # Now we have to check if any of the marked issues can actually be
        # fixed with our current issue-list.
        for issue_hash in fixes:
            issue_hash = issue_hash.strip()
            issue = id_to_issue.get(issue_hash)
            if not issue:
                kwargs = {'issue_hash': issue_hash,
                          'resolved_commit': resolved_commit}
                logger.info(locale_msg.bad_resolve.format(**kwargs))
                continue
            issue_was_resolved = True
            issue_commit = issue['commit']
            issue_branch = issue['branch']
            issue_description = issue['description']
            issue['resolved'] = True
            issue['resolved_in'] = resolved_commit
            resolved_log = '\n'.join([l.strip() for l in log])
            resolved_kwargs = {'issue_hash': issue_hash,
                               'issue_commit': issue_commit[:8],
                               'issue_branch': issue_branch,
                               'issue_description': issue_description,
                               'resolved_commit': resolved_commit[:8],
                               'resolved_branch': resolved_branch,
                               'resolved_log': resolved_log}
            msg = RESOLVED_TEMPLATE.format(**resolved_kwargs)
            updates.append((msg, resolved_kwargs, issue))
            print(msg)

    # No issues found, let the user know.
    if not issue_was_resolved:
        print(locale_msg.no_resolve)
        return

    # Ask if we should commit our changes
    if raw_input(locale_msg.ask_commit).lower() == locale_msg.ask_commit_yes:
        Git.branch_checkout(ISSUE_BRANCH)
        for msg, resolved_kwargs, issue in updates:
            issue.commit()
            Git.commit(Git.repository(), from_message=msg)

        # Now create a tag to mark the issue resolved in the resolved branch
        Git.branch_checkout(resolved_branch)
        for msg, update_kwargs, issue in updates:
            tag = locale_msg.tag_resolved.format(**update_kwargs)
            resolved = update_kwargs['resolved_commit']
            tag_created_kwargs = {'tag': tag, 'commit': resolved}
            print(locale_msg.tag_created.format(**tag_created_kwargs))
            Git.tag(tag, resolved)


def issue_delete(args):
    '''Deletes an issue.

    '''


def argument_create():
    '''Provides some organizational qualities to the argument parsing
    for git-issue.

    '''
    parser = argparse.ArgumentParser(prog='git issue')
    cmd = parser.add_subparsers(title='Available git-issue actions')

    def argument_create():
        '''Arguments pertaining to creating an issue

        '''
        option = cmd.add_parser('create', help='create a new issue')
        option.add_argument('-s', '--stdin',
                            action='store_true',
                            help='Read issue message from stdin')
        option.set_defaults(func=issue_create)

    def argument_list():
        '''Arguments pertaining to listing issues.

        '''
        option = cmd.add_parser('list', help='list available issues')
        option.add_argument('-i', '--id',
                            help='list only with a certain id',
                            default=[],
                            type=int,
                            action='append')

        option.add_argument('-t', '--tag',
                            help='list only by a certain tag',
                            default=[],
                            action='append')

        option.add_argument('-m', '--milestone',
                            help='list only by a certain milestone',
                            default=[],
                            action='append')

        option.add_argument('-a', '--assign',
                            help='list only by a certain user',
                            default=[],
                            action='append')

        option.add_argument('-s', '--short',
                            help='short list',
                            action='store_true')

        option.add_argument('-r', '--resolved',
                            default=False,
                            help='list only resolved issues',
                            action='store_true')

        option.set_defaults(func=issue_list)

    def argument_resolve():
        '''Arguments pertaining to resolving an issue.

        '''
        option = cmd.add_parser('resolve', help='resolve an issue')
        option.set_defaults(func=issue_resolve)

        option = cmd.add_parser('delete', help='delete an issue')
        option.set_defaults(func=issue_delete)

    def argument_general():
        '''Arguments pertaining to general use of git-issue.

        '''
        parser.add_argument('-q', '--quiet',
                            action='store_true',
                            help='supress all output')

        parser.add_argument('-v', '--verbose',
                            action='store_true',
                            help='enable debugging output')

    argument_create()
    argument_list()
    argument_resolve()
    argument_general()

    return parser


if __name__ == '__main__':
    parser = argument_create()
    args = parser.parse_args()

    if args.verbose:
        logger.setLevel(logging.DEBUG)

    if not Git.commit_exists():
        sys.exit(locale_msg.no_head)

    Git.stash()
    global_branch = Git.branch()
    logger.debug('Current branch is {}'.format(global_branch))

    try:
        # Check if the git-issues branch exists.
        issue_local_branch_exists = Git.local_branch_exists(ISSUE_BRANCH)
        repository_dir = Git.repository()
        issue_dir = repository_dir
        if not issue_local_branch_exists:
            # Create the issue directory if necessary
            logger.debug("Checking if remote exists")
            remote = Git.remote_branch_exists(ISSUE_BRANCH)
            if remote:
                logger.debug('Remote exists, checking it out.')
                Git.branch_remote_checkout(ISSUE_BRANCH, remote)
            else:
                logger.debug("Remote does not exist. Creating branch.")
                Git.branch_create(ISSUE_BRANCH, orphan=True)
                Git.rm(".", recursive=True)
                Git.commit(empty=True, from_message='Initial commit.')
        Git.branch_checkout(ISSUE_BRANCH)
        Git.pull()
        args.func(args)
    except AttributeError as e:
        logger.exception(e)
        parser.print_help()
    finally:
        Git.branch_checkout(global_branch)
        Git.stash_pop()
